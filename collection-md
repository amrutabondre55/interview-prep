
## 1Ô∏è‚É£ What is Collections Framework? (Start here)

> The Java Collections Framework is a **set of interfaces and classes** that provides a **standard way to store, manipulate, and retrieve groups of objects**.

### Why it exists

* Before collections ‚Üí Arrays (fixed size, no utilities)
* Collections give:

  * Dynamic size
  * Ready-made data structures
  * Better performance choices

---

## 2Ô∏è‚É£ Collection vs Collections (VERY COMMON QUESTION)

| Collection                    | Collections             |
| ----------------------------- | ----------------------- |
| Interface                     | Utility class           |
| Represents a group of objects | Provides helper methods |
| Root of List, Set, Queue      | Static methods only     |
| Example: `List`, `Set`        | `sort()`, `reverse()`   |

```java
Collection<Integer> c = new ArrayList<>();
Collections.sort(list);
```
> Collection is a data structure, Collections is a utility class.
---

## 3Ô∏è‚É£ Core Interfaces (Big Picture)

```
Iterable
   ‚Üì
Collection
   ‚Üì
--------------------------------
|        |         |
List     Set      Queue
                   |
                  Deque
Map ‚ùå (separate hierarchy)
```

---

## 4Ô∏è‚É£ List Interface (ORDERED + DUPLICATES ALLOWED)

### Properties

* Maintains insertion order
* Allows duplicates
* Index-based access

### Implementations

* `ArrayList`
* `LinkedList`
* `Vector` (legacy)

---

### 4.1 ArrayList vs LinkedList (Asked A LOT)

| Feature                | ArrayList     | LinkedList         |
| ---------------------- | ------------- | ------------------ |
| Data structure         | Dynamic Array | Doubly Linked List |
| Access                 | Fast (`O(1)`) | Slow (`O(n)`)      |
| Insert/Delete (middle) | Slow          | Fast               |
| Memory                 | Less          | More (prev + next) |

üëâ **When to use**

* **ArrayList** ‚Üí Read-heavy
* **LinkedList** ‚Üí Insert/Delete-heavy

---

### 4.2 Internal Working of ArrayList (VERY IMPORTANT)

```java
ArrayList<Integer> list = new ArrayList<>();
```

**Internally uses:**

```java
Object[] elementData;
```

### Steps:

1. Initial capacity = **10**
2. When array is full:

   * New capacity = `oldCapacity * 1.5`
3. Old elements copied to new array

üëâ **Why insertion is slow?**
Because resizing + copying happens.

---

### 4.3 Fail-Fast vs Fail-Safe Iterators

| Fail-Fast                                | Fail-Safe          |                   |
| ---------------------------------------- | ------------------ | ----------------- |
| Throws `ConcurrentModificationException` | No exception       |                   |
| Works on original collection             | Works on copy      |                   |
| Faster                                   | Safer              |                   |
| Examples                                 | ArrayList, HashMap | ConcurrentHashMap |

---

## 5Ô∏è‚É£ Set Interface (NO DUPLICATES)

### Properties

* No duplicate elements
* No index
* Uses `equals()` + `hashCode()`

---

### 5.1 HashSet vs LinkedHashSet vs TreeSet

| Feature        | HashSet     | LinkedHashSet         | TreeSet        |
| -------------- | ----------- | --------------------- | -------------- |
| Order          | No          | Insertion             | Sorted         |
| Data structure | HashMap     | HashMap + Linked list | Red-Black Tree |
| Null           | One allowed | One allowed           | ‚ùå Not allowed  |
| Speed          | Fastest     | Medium                | Slow           |

---

### 5.2 How HashSet Works Internally

```java
HashSet<String> set = new HashSet<>();
```

üëâ **Internally uses `HashMap`**

```java
HashMap<E, Object>
```

* Element = **key**
* Value = dummy object (`PRESENT`)

### Steps:

1. `hashCode()` ‚Üí bucket
2. `equals()` ‚Üí check duplicate
3. If match ‚Üí not added

üëâ **Why duplicates not allowed?**
Because `HashMap` does not allow duplicate keys.

---

## 6Ô∏è‚É£ Map Interface (KEY-VALUE PAIRS)

### Properties

* Keys must be unique
* Values can be duplicate
* Not part of Collection hierarchy

---

### 6.1 HashMap vs LinkedHashMap vs TreeMap

| Feature   | HashMap     | LinkedHashMap      | TreeMap        |
| --------- | ----------- | ------------------ | -------------- |
| Order     | No          | Insertion          | Sorted         |
| Null key  | One allowed | One allowed        | ‚ùå              |
| Structure | Hash table  | Hash + Linked list | Red-Black Tree |
| Speed     | Fastest     | Slightly slower    | Slow           |

---

## 6.2 Internal Working of HashMap (üî• MOST IMPORTANT üî•)

```java
HashMap<Integer, String> map = new HashMap<>();
```

### Step-by-Step:

1. `hashCode()` called on key
2. Hash converted to **bucket index**
3. If bucket empty ‚Üí insert
4. If collision:

   * `equals()` called
   * If same ‚Üí replace value
   * If different ‚Üí chain formed

### Collision Handling

* Java 7 ‚Üí Linked List
* Java 8+ ‚Üí **Red-Black Tree** (after threshold)

üëâ **Why tree?**
To improve performance from `O(n)` to `O(log n)`.

---

### 6.3 Why HashMap Allows One `null` Key?

* `null` has no `hashCode()`
* HashMap treats `null` as **bucket 0**
* Only one `null` key allowed to avoid ambiguity

---

## 7Ô∏è‚É£ ConcurrentHashMap vs HashMap

| Feature     | HashMap | ConcurrentHashMap |
| ----------- | ------- | ----------------- |
| Thread-safe | ‚ùå No    | ‚úÖ Yes             |
| Performance | Fast    | Slightly slower   |
| Locking     | No      | Bucket-level      |
| Null        | Allowed | ‚ùå Not allowed     |

üëâ **Why no null?**
To avoid ambiguity during concurrent reads.

---

## 8Ô∏è‚É£ Hashtable vs HashMap (Classic Question)

| Feature     | Hashtable | HashMap |
| ----------- | --------- | ------- |
| Thread-safe | ‚úÖ         | ‚ùå       |
| Performance | Slow      | Fast    |
| Null        | ‚ùå         | ‚úÖ       |
| Legacy      | Yes       | No      |

üëâ **Interview line:**

> Hashtable is synchronized, HashMap is not.

---
üîπ What is HashMap?

HashMap is a part of java.util package and it stores data in key‚Äìvalue pairs.
It allows one null key and multiple null values and provides O(1) average time complexity for put() and get().
